
import String
import string_util
import cstring
import List
import "sys/ctype.adept"

import "Context.adept"
import "Token.adept"
import "fs.adept"
import "string.adept"
import "util.adept"
import "datatypes.adept"
import "TokenKeyword.adept"
import "Version.adept"

func adept\lex(context *adept\Context, filename String) <<adept\Token> List> Optional {
    lexer adept\lex\Lexer(context)
    return lexer.lex(filename)
}

func adept\lex(context *adept\Context, buffer String, filename String) <<adept\Token> List> Optional {
    return adept\lex\Lexer(context).lexBuffer(buffer, filename)
}

struct adept\lex\Lexer (
    context *adept\Context,
    filename String,
    buffer String,
    object_index usize,
    tokenlist <adept\Token> List,
    version adept\Version,
    i usize,
) {
    constructor(context *adept\Context){
        this.context = context
    }

    func lex(filename String) <<adept\Token> List> Optional {
        contents String

        unless adept\fs\readTextContents(filename, &contents, ::WITH_NEWLINE_ENDING) {
            this.context.output.send(
                adept\Error(
                    sprintf("The file `%S` doesn't exist or can't be accessed", filename),
                    none()
                )
            )
            this.context.exit_code = 1
            return none()
        }

        return this.lexBuffer(contents, filename.commit())
    }

    func figureOutVersion() successful {
        this.version = ::TWO
        return true
    }

    func lexBuffer(buffer String, filename String) <<adept\Token> List> Optional {
        estimate usize = buffer.length / 3

        this.i = 0
        this.object_index = 0
        this.buffer = buffer.commit()
        this.tokenlist.clear()
        this.tokenlist.reserve(estimate)
        this.filename = filename.commit()

        unless this.figureOutVersion() {
            this.context.output.send(
                adept\Error(
                    sprintf(embed "msg/no_version_specified.txt", this.context.filename.get()),
                    none()
                )
            )

            this.context.exit_code = 1
            return none()
        }

        ok successful

        exhaustive switch this.version {
        case ::TWO
            ok = this.lexBufferAdept2()
        case ::THREE
            this.context.output.send(
                adept\Error(
                    "Only Adept 2.x code can be lexed right now",
                    some(adept\Source(
                        0,
                        0,
                        this.object_index
                    ))
                )
            )
            ok = false
        }
    
        if ok {
            return somePOD(this.tokenlist.donate())
        } else {
            this.context.exit_code = 1
            return none()
        }
    }

    func lexBufferAdept2 successful {
        while this.i < this.buffer.length {
            c ubyte = this.char()
            
            switch c {
            case ' 'ub, fallthrough
            case '\t'ub
                this.i += 1
            case '('ub
                this.simpleToken(::OPEN)
            case ')'ub
                this.simpleToken(::CLOSE)
            case '{'ub
                this.simpleToken(::BEGIN)
            case '}'ub
                this.simpleToken(::END)
            case '['ub
                this.simpleToken(::BRACKET_OPEN)
            case ']'ub
                this.simpleToken(::BRACKET_CLOSE)
            case ','ub
                this.simpleToken(::NEXT)
            case ';'ub
                this.simpleToken(::TERMINATE_JOIN)
            case '?'ub
                this.simpleToken(::MAYBE)
            case '\n'ub
                this.simpleToken(::NEWLINE)
            case '-'ub
                if isdigit(this.char(1)) {
                    unless this.number(), return false
                } else {
                    this.cases({
                        adept\lex\Case('='ub, ::SUBTRACT_ASSIGN),
                        adept\lex\Case('-'ub, ::DECREMENT),
                    }, ::SUBTRACT)
                }
            case '/'ub
                unless this.slash(), return false
            case '<'ub
                this.options({
                    adept\lex\Option("<<<=", ::BIT_LGC_LSHIFT_ASSIGN),
                    adept\lex\Option("<<<", ::BIT_LGC_LSHIFT),
                    adept\lex\Option("<<", ::BIT_LSHIFT),
                    adept\lex\Option("<=", ::LESSTHANEQ),
                    adept\lex\Option("<", ::LESSTHAN),
                })
            case '>'ub
                this.options({
                    adept\lex\Option(">>>=", ::BIT_LGC_RSHIFT_ASSIGN),
                    adept\lex\Option(">>>", ::BIT_LGC_RSHIFT),
                    adept\lex\Option(">>=", ::BIT_RSHIFT_ASSIGN),
                    adept\lex\Option(">>", :: BIT_RSHIFT),
                    adept\lex\Option(">=", ::GREATERTHANEQ),
                    adept\lex\Option(">", ::GREATERTHAN),
                })
            case '='ub
                this.cases({
                    adept\lex\Case('='ub, ::EQUALS),
                    adept\lex\Case('>'ub, ::STRONG_ARROW),
                }, ::ASSIGN)
            case '!'ub
                this.cases({
                    adept\lex\Case('='ub, ::NOTEQUALS),
                    adept\lex\Case('!'ub, ::TOGGLE),
                }, ::NOT)
            case ':'ub
                this.cases({
                    adept\lex\Case(':'ub, ::ASSOCIATE),
                }, ::COLON)
            case '+'ub
                this.cases({
                    adept\lex\Case('='ub, ::ADD_ASSIGN),
                    adept\lex\Case('+'ub, ::INCREMENT),
                }, ::ADD)
            case '*'ub
                this.cases({
                    adept\lex\Case('='ub, ::MULTIPLY_ASSIGN),
                }, ::MULTIPLY)
            case '%'ub
                this.cases({
                    adept\lex\Case('='ub, ::MODULUS_ASSIGN),
                }, ::MODULUS)
            case '^'ub
                this.cases({
                    adept\lex\Case('='ub, ::BIT_XOR_ASSIGN),
                }, ::BIT_XOR)
            case '~'ub
                this.cases({
                    adept\lex\Case('>'ub, ::GIVES),
                }, ::BIT_COMPLEMENT)
            case '&'ub
                this.cases({
                    adept\lex\Case('&'ub, ::UBERAND),
                    adept\lex\Case('='ub, ::BIT_AND_ASSIGN),
                }, ::AMPERSAND)
            case '|'ub
                this.cases({
                    adept\lex\Case('|'ub, ::UBEROR),
                    adept\lex\Case('='ub, ::BIT_OR_ASSIGN),
                }, ::BIT_OR)
            case '.'ub
                this.stacking('.'ub, {adept\TokenID::MEMBER, ::RANGE, ::ELLIPSIS})
            case '"'ub
                unless this.string(), return false
            case '\''ub
                unless this.cstring(), return false
            case '#'ub
                this.running(::META)
            case '$'ub
                this.running(::POLYMORPH)
            default
                if isalpha(c) || c == '_'ub || c == '\\'ub {
                    this.running(::WORD)
                    continue
                }

                if isdigit(c) {
                    unless this.number(), return false
                    continue
                }

                this.context.output.send(
                    adept\Error(
                        sprintf("Unexpected character '%c' while lexing (char code %d)", this.char(), this.char()),
                        some(adept\Source(this.i, 1, this.object_index))
                    )
                )
                return false
            }
        }

        return true
    }

    func add(id adept\TokenID, extra ptr, source adept\Source) {
        this.tokenlist.add(adept\Token(id, extra as *adept\TokenExtra, source))
    }

    func simpleToken(token_id adept\TokenID) {
        this.add(token_id, null, adept\Source(this.object_index, this.i, 1))
        this.i += 1
    }

    func cases(possibilities <adept\lex\Case> Array, default_token_id adept\TokenID) {
        c ubyte = this.char(1)

        each adept\lex\Case in possibilities {
            if it.extension == c {
                this.add(it.token_id, null, adept\Source(this.object_index, this.i, 2))
                this.i += 2
                return
            }
        }

        this.add(default_token_id, null, adept\Source(this.object_index, this.i, 1))
        this.i += 1
    }

    func rest(offset usize = 0) StringView {
        return this.buffer.range(this.i + offset, this.buffer.length)
    }

    func options(options <adept\lex\Option> Array) {
        rest StringView = this.rest()

        each adept\lex\Option in options {
            if rest.startsWith(it.sequence) {
                this.add(it.token_id, null, adept\Source(this.object_index, this.i, it.sequence.length))
                this.i += it.sequence.length
                return
            }
        }
    }

    func stacking(c ubyte, mappings <adept\TokenID> Array) {
        stride usize = 1

        while stride < mappings.length && this.char(stride) == c {
            stride += 1
        }

        this.add(mappings[stride - 1], null, adept\Source(this.i, stride, this.object_index))
        this.i += stride
    }

    func string successful {
        rest StringView = this.rest(1)
        unescaped, escaped String
        
        unless adept\lex\escapableUntil(rest, '"'ub, '\\'ub, &unescaped) {
            this.errorUnterminatedString()
            return false
        }

        unless this.stringUnescapeOrFail(unescaped, &escaped) {
            return false
        }

        this.add(
            ::STRING,
            new String(escaped.commit()) as *adept\TokenExtra,
            adept\Source(
                this.i,
                unescaped.length + 2,
                this.object_index
            )
        )

        this.i += unescaped.length + 2
        return true
    }

    func cstring successful {
        rest StringView = this.rest(1)
        unescaped, escaped String

        unless adept\lex\escapableUntil(rest, '\''ub, '\\'ub, &unescaped) {
            this.errorUnterminatedString()
            return false
        }

        unless this.stringUnescapeOrFail(unescaped, &escaped) {
            return false
        }

        // Handle special case of character literals differently
        if(escaped.length == 1){
            rest = this.rest(unescaped.length + 2)

            if rest.startsWith("ub") {
                // Actually a 'ubyte' character literal
                this.add(::UBYTE, adept\toHeap(escaped[0] as ulong), adept\Source(this.i, unescaped.length + 4, this.object_index))
                this.i += unescaped.length + 4
                return true
            } elif rest.startsWith("sb") {
                // Actually a 'byte' character literal
                this.add(::BYTE, adept\toHeap(escaped[0] as long), adept\Source(this.i, unescaped.length + 4, this.object_index))
                this.i += unescaped.length + 4
                return true
            }
        }

        this.add(::CSTRING, new String(escaped.commit()), adept\Source(this.i, unescaped.length + 2, this.object_index))
        this.i += unescaped.length + 2
        return true
    }

    func char(offset usize = 0) ubyte = this.i + offset < this.buffer.length ? this.buffer[this.i + offset] : '\0'ub

    func number successful {
        define buf_size = 96

        is_hex, did_exp bool = false
        can_dot bool = true
        start_i usize = this.i

        if this.char() == '-'ub {
            // Negative number
            this.i++
        } else {
            beginning StringView = this.buffer.range(this.i, this.buffer.length)

            if beginning.startsWith("0x") || beginning.startsWith("0X") {
                is_hex = true
                can_dot = false
                this.i += 2
            }
        }

        while true {
            c ubyte = this.char()

            if isdigit(c) || c == '_'ub {
                this.i++
            } elif c == '.'ub && can_dot {
                can_dot = false
                this.i++
            } elif is_hex && ((c >= 'A'ub && c <= 'F'ub) || (c >= 'a'ub && c <= 'f'ub)) {
                this.i++
            } elif !did_exp && (c == 'e'ub || c == 'E'ub) {
                this.i++
                did_exp = true
                can_dot = false
                c = this.char()

                if c == '+'ub || c == '-'ub {
                    this.i++
                }
            } else {
                break
            }
        }

        number String = this.buffer.range(start_i, this.i).replace('_'ub, "", ::OR_VIEW)

        token_id adept\TokenID
        data ptr
        stride usize = this.i - start_i

        // Respect integer/float suffixes
        switch this.char() {
        case 'u'ub
            switch this.char(1) {
            case 'b'ub
                token_id = ::UBYTE
                data = adept\toHeap(toUlong(number, is_hex) as adept\unsigned)
                stride += 2
            case 's'ub
                token_id = ::USHORT
                data = adept\toHeap(toUlong(number, is_hex) as adept\unsigned)
                stride += 2
            case 'i'ub
                token_id = ::UINT
                data = adept\toHeap(toUlong(number, is_hex) as adept\unsigned)
                stride += 2
            case 'l'ub
                token_id = ::ULONG
                data = adept\toHeap(toUlong(number, is_hex) as adept\unsigned)
                stride += 2
            case 'z'ub
                token_id = ::USIZE
                data = adept\toHeap(toUlong(number, is_hex) as adept\unsigned)
                stride += 2
            default
                this.context.output.send(
                    adept\Error(
                        "Expected valid number suffix after 'u' base suffix",
                        some(
                            adept\Source(this.i + stride + 1, 1, this.object_index)
                        )
                    )
                )
                return false
            }
        case 's'ub
            switch this.char(1) {
            case 'b'ub
                token_id = ::BYTE
                data = adept\toHeap(toLong(number, is_hex) as adept\signed)
                stride += 2
            case 's'ub
                token_id = ::SHORT
                data = adept\toHeap(toLong(number, is_hex) as adept\signed)
                stride += 2
            case 'i'ub
                token_id = ::INT
                data = adept\toHeap(toLong(number, is_hex) as adept\signed)
                stride += 2
            case 'l'ub
                token_id = ::LONG
                data = adept\toHeap(toLong(number, is_hex) as adept\signed)
                stride += 2
            default
                token_id = ::SHORT
                data = adept\toHeap(toLong(number, is_hex) as adept\signed)
                stride += 1
            }
        case 'b'ub
            token_id = ::BYTE
            data = adept\toHeap(toLong(number, is_hex) as adept\signed)
            stride += 1
        case 'i'ub
            token_id = ::INT
            data = adept\toHeap(toLong(number, is_hex) as adept\signed)
            stride += 1
        case 'l'ub
            token_id = ::LONG
            data = adept\toHeap(toLong(number, is_hex) as adept\signed)
            stride += 1
        case 'f'ub
            token_id = ::FLOAT
            data = adept\toHeap(toDouble(number) as adept\floating)
            stride += 1
        case 'd'ub
            token_id = ::DOUBLE
            data = adept\toHeap(toDouble(number) as adept\floating)
            stride += 1
        default
            if (!is_hex && !can_dot) || did_exp {
                // Default to normal generic floating-point
                token_id = ::GENERIC_FLOAT
                data = adept\toHeap(toDouble(number) as adept\floating)
            } elif adept\mustBeUnsigned64(number, is_hex) {
                // Numbers that cannot be expressed using int64 will be promoted to uint64
                token_id = ::ULONG
                data = adept\toHeap(toUlong(number, is_hex) as adept\unsigned)
            } else {
                // Otherwise, default to normal generic integer
                token_id = ::GENERIC_INT
                data = adept\toHeap(toLong(number, is_hex))
            }
        }
        
        // Add number token
        this.add(token_id, data, adept\Source(start_i, stride, this.object_index))
        return true
    }

    func running(intent adept\TokenID) {
        // Contains additional logic for intents:
        // - adept\TokenID::WORD
        // - adept\TokenID::POLYMORPH

        flag_length usize = intent == ::WORD ? 0 : 1
        start_i usize = this.i

        this.i += flag_length

        while this.i < this.buffer.length {
            c ubyte = this.char()

            if c == '_'ub || isalnum(c) {
                this.i++
                continue
            }

            if intent == ::WORD {
                if c == '\\'ub || (c == ':'ub && (isalnum(this.char(1)) || c == '_'ub)) {
                    this.i++
                    continue
                }
            }

            if intent == ::POLYMORPH && this.i == start_i {
                if c == '~'ub {
                    this.i++
                    continue
                }

                if c == '#'ub {
                    intent = ::POLYCOUNT
                    start_i++
                    this.i++
                    flag_length++
                    continue
                }
            }

            break
        }

        // Create string to hold identifier
        identifier String = this.buffer.range(start_i, this.i)

        if intent == ::WORD {
            keyword_token_id adept\TokenID = adept\getTokenForKeyword(identifier)
            
            // Handle word tokens that should be keywords
            if keyword_token_id != ::NONE {
                this.add(keyword_token_id, null, adept\Source(start_i, identifier.length, this.object_index))
                return
            } elif identifier == "elif" {
                this.add(::ELSE, null, adept\Source(start_i, 2, this.object_index))
                this.add(::IF, null, adept\Source(start_i + 2, 2, this.object_index))
                return
            }

            // Otherwise not a keyword...
            // Legacy alternative syntax ':' instead of '\\' as a namespace character
            identifier = identifier.replace(':'ub, "\\", ::OR_VIEW)
        }

        // Create token
        this.add(
            intent,
            new String(identifier.commit()),
            adept\Source(start_i, identifier.length + flag_length, this.object_index)
        )
    }

    func slash successful {
        switch(this.char(1)){
        case '/'ub
            this.i += 1
            while this.char() != '\n'ub {
                this.i += 1
            }
        case '*'ub
            start_i usize = this.i - 1
            this.i += 1

            while true {
                unless this.i + 1 < this.buffer.length {
                    source adept\Source = adept\Source(start_i, 2, this.object_index)
                    this.context.output.send(adept\Error("Unterminated multi-line comment", some(source)))
                    return false
                }

                if this.buffer.range(this.i, 2).startsWith("*/") {
                    this.i += 2
                    break
                }

                this.i += 1
            }
        default
            this.cases({
                adept\lex\Case('='ub, ::DIVIDE_ASSIGN),
            }, ::DIVIDE)
        }

        return true
    }

    func stringUnescapeOrFail(string String, out result *String) successful {
        error <adept\string\UnescapeError> Optional = adept\string\unescape(string, result)

        if error.has {
            this.errorUnknownEscapeSequence(error.ref())
            return false
        }

        return true
    }

    func errorUnterminatedString {
        this.context.output.send(
            adept\Error(
                "Unterminated string literal",
                some(adept\Source(this.i, 1, this.object_index))
            )
        )
    }

    func errorUnknownEscapeSequence(error *adept\string\UnescapeError) {
        position usize = this.i + 1 + error.relative_position
        invalid_escape_char ubyte = this.buffer[position + 1]

        this.context.output.send(
            adept\Error(
                sprintf("Unknown escape sequence '\\%c\'", invalid_escape_char),
                some(adept\Source(position, 2, this.object_index))
            )
        )
    }
}

record adept\lex\Case (extension ubyte, token_id adept\TokenID)
record adept\lex\Option (sequence String, token_id adept\TokenID)

func adept\lex\escapableUntil(rest StringView, terminator, escape_prefix ubyte, out output *StringView) successful {
    beginning *ubyte = rest.array
    end *ubyte = beginning
    eof *ubyte = beginning at rest.length

    while end < eof {
        if *end == terminator {
            *output = rest.range(0, (end - beginning) as usize)
            return true
        } else if *end == escape_prefix {
            end = end at 2
        } else {
            end = end at 1
        }
    }

    *output = ""
    return false
}

func adept\lex\getLocation(buffer String, index usize, out line, column *usize) {
    newlines int = 0
    last_newline *ubyte = null

    for i usize = 0; i != index; i++ {
        if buffer[i] == '\n'ub {
            last_newline = buffer at i
            newlines++
        }
    }

    *line = 1 + newlines
    *column = last_newline ? cast usize (buffer at index - last_newline) : index + 1
}
